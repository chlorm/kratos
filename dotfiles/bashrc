#!/usr/bin/env bash
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: Local BashRC Configuration File
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Assumed Directory & File Structure:
##      ~/.bashrc
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      # -- commented variables

## [http://en.wikipedia.org/wiki/Unicode_symbols]

#export PATH="${PATH}:/usr/bin"
#export LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:/usr/lib64:/usr/lib32"

export XDG_DATA_HOME="$HOME/.local/share"
export XDG_CONFIG_HOME="$HOME/.config"
export XDG_CACHE_HOME="$HOME/.cache"
export XDG_DOWNLOAD_DIR="$HOME/Downloads"

export EDITOR='vim'

## Test for an interactive shell.
if [[ $- != *i* ]] ; then
	## Shell is non-interactive.  Be done now!
	return
fi

export LANGUAGE="en_US:en"

# Append '*' if git branch is dirty
git_dirty () {
    [[ $(git status 2> /dev/null | \
        tail -n1) != *"working directory clean"* ]] && echo "*"
}
# Find current git branch
git_branch () {
    git branch --no-color 2> /dev/null | \
    sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(git_dirty)/"
}

# Bash prompt »
PS1="\
\[\e[1;32m\]\u\
\[\e[30m\]@\
\[\e[37m\]\h\
\[\e[30m\][\
\[\e[1;35m\]\w\
\[\e[30m\]]\
\[\e[1;37m\]\
\$([[ -n \$(git branch 2> /dev/null) ]] && \
    echo \"\[\e[1;32m\]git\[\e[1;30m\]∫\")\
\[\e[1;37m\]\$(git_branch)\
\[\e[0m\]\
\[\e[36m\]〉"

## [ls colors]
#LS_COLORS='no=00:fi=00:di=01;35:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.7z=01;34:*.iso=01;34:*.tar=01;34:*.tgz=01;34:*.zip=01;34:*.gz=01;34:*.bz2=01;34:*.deb=01;34:*.rpm=01;34:*.jar=01;34:*.xz=01;34:*.jpg=01;33:*.jpeg=01;33:*.gif=01;33:*.bmp=01;33:*.tga=01;33:*.xbm=01;33:*.tif=01;35:*.tiff=01;33:*.png=01;33:*.avc=01;32:*.h264=01;32:*.h265=01;32:*.hevc=01;32:*.hvc=01;32:*.mkv=01;32:*.mov=01;32:*.mpg=01;32:*.mpeg=01;32:*.avi=01;32:*.flv=01;32:*.mp4=01;32:*.ape=01;31:*.flac=01;31:*.mp3=01;31:*.mpc=01;31:*.ogg=01;31:*.wav=01;31:';
#export LS_COLORS
## TODO: Create global color scheme and export variables

## [aliases]
alias sha1="openssl sha1"
alias sha256="openssl sha256"
alias sha512="openssl sha512"
alias youtube="youtube-dl --max-quality --no-check-certificate --prefer-insecure --console-title"
alias music="ncmpcpp"
alias tarxz="tar cjvf"

## [gentoo specific]
alias inst="sudo emerge --ask"
alias search="emerge --search"
alias uses="equery uses"
alias layup="sudo layman -S"
update () {
    sudo emerge --sync
    sudo emerge --ask --update --deep --with-bdeps=y --newuse --keep-going @world
    ## TODO: add all 9999 and recompile on update [in order of dependencies]
    ## x265,libvpx,ffmpeg,vlc,rtorrent
}
## [list all packages from overlays with corresponding overlay name]
fromover () {
    for i in /var/db/pkg/*/*; do
        if ! grep gentoo $i/repository >/dev/null; then
            echo -e "`basename $i`\t`cat $i/repository`"
        fi
    done
}

#[btrfs]
alias defragmentroot="sudo btrfs filesystem defragment -r -v -clzo /"
alias defragmenthome="sudo btrfs filesystem defragment -r -v /home"

# [color man pages]
## TODO: update color scheme to match global
man () {
    env \
    LESS_TERMCAP_mb=$(printf "\e[1;31m") \
    LESS_TERMCAP_md=$(printf "\e[1;31m") \
    LESS_TERMCAP_me=$(printf "\e[0m") \
    LESS_TERMCAP_se=$(printf "\e[0m") \
    LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
    LESS_TERMCAP_ue=$(printf "\e[0m") \
    LESS_TERMCAP_us=$(printf "\e[1;32m") \
    man "$@"
}

##[add all albums by music artist to local music library and convert lossless to mp3]
addartist () {
    if [[ -z "$@" ]];then echo "ERROR: no input";exit 1;fi
    inputArtist="$@"
    artistAddPath="/home/jackal/Music/\"${@}\""
    ## [download artist's albums]
    scp -r -P 4497 "jackal@192.168.1.5:${artistAddPath}" "$HOME/Music/"
    ## [check for flac and convert to ogg]
    find $HOME/Music/"${inputArtist}" -depth -name '*' | \
    while read curWorkFile;do
        curWorkFileExt=${curWorkFile##*.}
        if [[ -z "$curWorkFileExt" ]];then echo "nothing to do here";
        elif [[ "$curWorkFileExt" = "flac" ]];then
            ## [path to current file]
            curWorkDir=$(dirname "$curWorkFile")
            ## [filename w/ ext]
            fileName=$(basename "$curWorkFile")
            ## [filename w/o ext]
            fileName=$(echo "$fileName" | sed -r 's/\.[[:alnum:]]+$//')
            ffmpeg -y -i "$curWorkFile" -c:a libvorbis -qscale:a 5 "$curWorkDir/$fileName.ogg" & \
            ffmpegPid=$!
            ## [don't delete before encoding completes]
            wait "$ffmpegPid"
            rm -f "$curWorkFile"
        fi;done
    exit 0
}