#!/usr/bin/env sh

prompt_color () { # Get colors for the current shell

  [ "$(shell_nov)" = "zsh" ] && echo -n '%{' || echo -n '\['

  case "$1" in

    'black')
      [ "$2" -eq "0" ] && echo -n '\e[0;30m' || echo -n '\e[1;30m'
      ;;

    'blue')
      [ "$2" -eq "0" ] && echo -n '\e[0;34m' || echo -n '\e[1;34m'
      ;;

    'cyan')
      [ "$2" -eq "0" ] && echo -n '\e[0;36m' || echo -n '\e[1;36m'
      ;;

    'green')
      [ "$2" -eq "0" ] && echo -n '\e[0;32m' || echo -n '\e[1;32m'
      ;;

    'magenta')
      [ "$2" -eq "0" ] && echo -n '\e[0;35m' || echo -n '\e[1;35m'
      ;;

    'red')
      [ "$2" -eq "0" ] && echo -n '\e[0;31m' || echo -n '\e[1;31m'
      ;;

    'white')
      [ "$2" -eq "0" ] && echo -n '\e[0;37m' || echo -n '\e[1;37m'
      ;;

    'yellow')
      [ "$2" -eq "0" ] && echo -n '\e[0;33m' || echo -n '\e[1;33m'
      ;;

    'underline')
      echo -n '\e[4m'
      ;;

    'reset')
      echo -n '\e[0m'
      ;;

    *)
      echo -n '\e[0m'
      ;;

  esac

  [ "$(shell_nov)" = "zsh" ] && echo -n '%}' || echo -n '\]'

}

prompt_vcs () { # Determine if the current directory is a vcs repo

  prompt_bzr && return 0

  prompt_cvs && return 0

  prompt_drc && return 0

  prompt_git && return 0

  prompt_mhg && return 0

  prompt_svn && return 0

  return 0

}

prompt_bzr () {

  path_hasbin bzr > /dev/null 2>&1 || return 1

  local BZR

  if BZR=$(bzr root 2> /dev/null) ; then

    echo -ne "$(prompt_color green 1)bzr$(prompt_color black 1)∫$(prompt_color white 1)"

  else

    return 1

  fi

  return 0

}

prompt_cvs () { # Concurrent Versions System

  path_hasbin cvs > /dev/null 2>&1 || return 1

  local CVS

  if CVS=$(cvs status 2> /dev/null) ;  then

    echo -ne "$(prompt_color green 1)cvs$(prompt_color black 1)∫$(prompt_color white 1)"

  else

    return 1

  fi

  return 0

}

prompt_drc () { # Darcs

  # Does not work yet, force failure
  return 1

  path_hasbin darcs > /dev/null 2>&1 || return 1

  echo -ne "$(prompt_color green 1)darcs$(prompt_color black 1)∫$(prompt_color white 1)"

  return 0

}

prompt_git () { # Git

  path_hasbin git > /dev/null 2>&1 || return 1

  local GIT

  if GIT=$(git status 2> /dev/null) ; then

    prompt_git_dirty () { # Append '*' if git branch is dirty

      local GITSTATUS

      GITSTATUS="$(git status 2> /dev/null | tail -n 1 | grep -m 1 -w -o 'working directory clean')"

      [ "$GITSTATUS" != "working directory clean" ] && { echo "*" ; }

      return 0

    }

    prompt_git_branch () { # Find current git branch

      local GITBRANCH

      GITBRANCH=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(prompt_git_dirty)/")

      [ -n "$GITBRANCH" ] && { echo "$GITBRANCH" ; }

      return 0

    }

    echo -ne "$(prompt_color green 1)git$(prompt_color black 1)∫$(prompt_color white 1)$(prompt_git_branch)"

  else

    return 1

  fi

  return 0

}

prompt_mhg () { # Mercurial

  path_hasbin hg > /dev/null 2>&1 || return 1

  local MHG

  if MHG=$(hg status --no-color 2> /dev/null) ; then

    echo -ne "$(prompt_color green 1)hg$(prompt_color black 1)∫$(prompt_color white 1)"

  else

    return 1

  fi

  return 0

}

prompt_svn () { # Subversion

  path_hasbin svn > /dev/null 2>&1 || return 1

  local SVN

  if SVN="$(svn info 2> /dev/null)" ; then

    echo -ne "$(prompt_color green 1)svn$(prompt_color black 1)∫$(prompt_color white 1)"

  else

    return 1

  fi

  return 0

}

prompt_configure () {

  # Create Prompt
  case "$(shell_nov)" in

    'zsh')
      PROMPT="[$NCOLOR%n$(prompt_color reset 0)@"
      PROMPT="$PROMPT$HCOLOR%m$(prompt_color reset 0):"
      PROMPT="$PROMPT$DCOLOR%30<...<%~%<<$(prompt_color reset 0)]%(!.#.$) "
      ;;

    'bash'|'dash')
      export PS1="$(prompt_color green 1)\u$(prompt_color black 1)@$(prompt_color white 1)\h$(prompt_color black 1)[$(prompt_color magenta 1)\w$(prompt_color black 1)]$(prompt_vcs)$(prompt_color cyan 0)〉$(prompt_color reset)"
      ;;

  esac

}
