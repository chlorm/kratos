#!/usr/bin/env sh

# Get colors for the current shell
shell_color () {
  [ "$(shell_nov)" = "zsh" ] && echo -n '%{' || echo -n '\['
  case "$1" in
    black)
      [ "$2" -eq "0" ] && echo -n '\e[0;30m' || echo -n '\e[1;30m'
      ;;
    blue)
      [ "$2" -eq "0" ] && echo -n '\e[0;34m' || echo -n '\e[1;34m'
      ;;
    cyan)
      [ "$2" -eq "0" ] && echo -n '\e[0;36m' || echo -n '\e[1;36m'
      ;;
    green)
      [ "$2" -eq "0" ] && echo -n '\e[0;32m' || echo -n '\e[1;32m'
      ;;
    magenta)
      [ "$2" -eq "0" ] && echo -n '\e[0;35m' || echo -n '\e[1;35m'
      ;;
    red)
      [ "$2" -eq "0" ] && echo -n '\e[0;31m' || echo -n '\e[1;31m'
      ;;
    white)
      [ "$2" -eq "0" ] && echo -n '\e[0;37m' || echo -n '\e[1;37m'
      ;;
    yellow)
      [ "$2" -eq "0" ] && echo -n '\e[0;33m' || echo -n '\e[1;33m'
      ;;
    reset)
      echo -n '\e[0m'
      ;;
    *)
      echo -n '\e[0m'
      ;;
  esac
  [ "$(shell_nov)" = "zsh" ] && echo -n '%}' || echo -n '\]'
}

# Append '*' if git branch is dirty
git_dirty () {
    [[ $(git status 2> /dev/null | \
        tail -n1) != *"working directory clean"* ]] && echo "*"
}
# Find current git branch
git_branch () {
    git branch --no-color 2> /dev/null | \
    sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(git_dirty)/"
}

# Setup the theme for the shell
shell_theme () {
  [ "$(shell_nov)" = "fish" ] && return 0

  # Colors for LS
  os_base '\(Linux\|Cygwin\)' && { eval "$(dircolors -b)"; alias ls='ls --color=auto'; }
  os_base '\(FreeBSD\)' && { export CLICOLOR=1; export LSCOLORS="ExGxFxdxCxDhDxaBadaCeC"; }

  # 256 Colors in the Terminal
  if [ "$TERM" = "xterm" ] || [ "$TERM" = "rxvt-unicode-256color" ]; then
    export TERM="xterm-256color"
    unset COLORTERM
  fi

  # Setup Special Colors
  if info_root; then
    NCOLOR="$(shell_color cyan 0)"
  else
    NCOLOR="$(shell_color white 1)"
  fi

  if info_ws; then
    HCOLOR="$(shell_color green 0)"
  else
    HCOLOR="$(shell_color red 0)"
  fi

  DCOLOR="$(shell_color yellow 1)"

  # Create Prompt
  if [ "$(shell_nov)" = "zsh" ];then
    PROMPT="[$NCOLOR%n$(shell_color reset 0)@"
    PROMPT="$PROMPT$HCOLOR%m$(shell_color reset 0):"
    PROMPT="$PROMPT$DCOLOR%30<...<%~%<<$(shell_color reset 0)]%(!.#.$) "
  else
    PS1="$(shell_color green 1)\u$(shell_color black 1)@$(shell_color white 1)\h$(shell_color black 1)[$(shell_color magenta 1)\w$(shell_color black 1)]\$([[ -n \$(git branch 2>/dev/null) ]] && echo \"$(shell_color green 1)git$(shell_color black 1)∫\")$(shell_color white 1)\$(git_branch)$(shell_color cyan 0)〉$(shell_color reset)"
  fi
}

# Create the temporary directory for the shell
shell_tmp () {
  local TMP
  if TMP="$(dir_tmp)"; then
    export HISTFILE="$TMP/history_$(shell_nov)"
    export SAVEHIST="9999"
  else
    export HISTFILE="/dev/null"
    export SAVEHIST="0"
  fi
}

# Initializes useful functions if the caller is a shell
shell_init () {
  shell_tmp
  path_add "$HOME/.bin"
  path_add "$HOME/.cabal/bin"
  agent_auto

  alias root="sudo_wrap su -"
  alias sprunge="curl -F 'sprunge=<-' http://sprunge.us" 
  alias t='laptop_bat; date'
  alias sha1="openssl sha1"
  alias sha256="openssl sha256"
  alias sha512="openssl sha512"
  alias youtube="youtube-dl --max-quality --no-check-certificate --prefer-insecure --console-title"
  alias music="ncmpcpp"
  alias tarxz="tar cjvf"
  # Btrfs
  alias defragmentroot="sudo btrfs filesystem defragment -r -v -clzo /"
  alias defragmenthome="sudo btrfs filesystem defragment -r -v /home"
  # Gentoo
  alias inst="sudo emerge --ask"
  alias search="emerge --search"
  alias uses="equery uses"
  alias layup="sudo layman -S"
  # Directories
  export XDG_DATA_HOME="$HOME/.local/share"
  export XDG_CONFIG_HOME="$HOME/.config"
  export XDG_CACHE_HOME="$HOME/.cache"
  export XDG_DOWNLOAD_DIR="$HOME/Downloads"
  # Defaults
  export LANGUAGE="en_US:en"
  export EDITOR="vim"
  export PAGER="less"
  export BLOCKSIZE="K"

  export GOPATH="$HOME/.go"
  export PATH="$PATH:$HOME/.go/bin"
  #export PATH="${PATH}:/usr/bin"
  #export LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:/usr/lib64:/usr/lib32"
}

# Returns the name of the preferred shell
shell_get_best () {
  # Bash
  if path_hasbin bash; then
    echo "bash"
    return 0
  # Fish
  elif path_hasbin fish; then
    echo "fish"
    return 0
  # Zsh
  elif path_hasbin zsh; then
    VER="$(zsh --version | awk '{print $2}')"
	  VER="$(printf "4.3.9\n%s" "$VER" | \
      sort -bt. -k1,1n -k2,2n -k3,3n -k4,4n -k5,5n | \
      awk 'NR==1')"
	  if [ "$VER" = "4.3.9" ]; then echo "zsh"
      return 0
    fi
  # Fallback to sh
  else 
    echo "sh"
  fi
}

# Automatically executes the preferred shell
shell_best () {
  if [ "$(shell_nov)" != "$(shell_get_best)" ]; then
    exec $(shell_get_best) $@
    exit $?
  fi
}

# Automatically configures the shell configuration files
shell_auto () {
  config_ln "bash_profile" "bashrc" "bash_logout" "zshrc" \
            "zprofile" "zlogout" "config/fish" "tmux.conf" \
            "config/sakura"
}
