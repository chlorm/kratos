#!/usr/bin/env sh

p_and_q () {

  local STAT

  STAT="$1"
  shift 1
  echo "$@"
  exit $STAT

}

dir_tmp () { # Get the path to the temporary directory

  local DIR_TMP

  dir_tmp_tryall

  [ "$DIR_TMP" = "" ] && { echo "Failed to find a temporary folder" >&2 ; return 1 ; }

  [ ! -d "$DIR_TMP" ] && mkdir "$DIR_TMP" && chmod 0700 "$DIR_TMP"
  symlink "$DIR_TMP" "$HOME/.tmp"
  mkdir "$DIR_TMP/cache" >/dev/null 2>&1
  symlink "$DIR_TMP/cache" "$HOME/.cache"
  echo "$DIR_TMP"

}

dir_tmp_tryall() {

  dir_tmp_one "$ROOT/dev/shm" && return 0
  dir_tmp_one "$ROOT/run/shm" && return 0
  dir_tmp_one "$ROOT/tmp" && return 0
  dir_tmp_one "$ROOT/var/tmp" && return 0

}

dir_tmp_one () {

  [ -w "$1" ] || return 1

  mount | grep '\(tmpfs\|ramfs\)' | grep $1 >/dev/null || return 1
  DIR_TMP="$1/$USER"

}

path_bin () { # Finds the path to the binary

  [ "$#" -ne "1" ] && return 2

  path_hasbin "$1" && type "$1" | awk '{print $3}' && return 0

  return 1

}

proc_exists () { # Checks to see if the process is running

  [ "$#" -ne "1" ] && return 1

  kill -0 $1 >/dev/null 2>&1

}

check_pidfile () { # Checks the pidfile to see if the process is running

  [ -f "$1" ] && proc_exists "$(cat $1 2>/dev/null)"

}
