#!/usr/bin/env sh

symlink () { # Make sure the symbolic link points to the correct location $2 -> $1

  mkdir -p "$(dirname "$2")"
  if [ "$(readlink -f "$2")" != "$1" ] ; then
    rm -rf "$2"
    if [ -f "$1" ] || [ -d "$1" ] ; then
      ln -s "$1" "$2" 2>/dev/null || return 1
    else
      return 1
    fi
  fi

}

run_quiet () { # Start an application in the background

  path_hasbin "$1" || return 1

  local PID

  PID="$(pgrep $1)"

  [ -z "$PID" ] && { "$@" >/dev/null 2>&1 ; }

}

p_and_q () {

  local STAT

  STAT="$1"
  shift 1
  echo "$@"
  exit $STAT

}

y_or_n_validate () { # Validate the answer to a yes or no question

  local ANS

  ANS="$(tolower $1)"

  [ "$ANS" = "yes" ] && return 0
  [ "$ANS" = "y" ] && return 0
  [ "$ANS" = "no" ] && return 1
  [ "$ANS" = "n" ] && return 1

  return 2

}

y_or_n () { # Ask a yes or no question

  local ANS
  local RET

  while true ; do
    echo -n "$1 "
    y_or_n_validate "$2"
    RET="$?"
    if [ "$RET" -eq "0" ] ; then
      echo -n "(Y/n) "
      read ANS
      [ -z "$ANS" ] && return 0
    elif [ "$RET" -eq "1" ] ; then
      echo -n "(y/N)" 
      read ANS
      [ -z "$ANS" ] && return 1
    else
      echo -n "(y/n) "
      read ANS
    fi
    y_or_n_validate "$ANS"
    RET="$?"
    [ "$RET" -lt "2" ] && return $RET
  done

}

password_confirmation () {

  local PASS1
  local PASS2

  while true ; do
    read -s -p "Password: " PASS1
    echo
    read -s -p "Confirm: " PASS2
    echo
    [ "$PASS1" = "$PASS2" ] && break
    echo "WARNING: passwords do not match, try again"
  done

  echo "$PASS1" >/dev/null 2>&1 && return 0

  return 1

}

dir_tmp () { # Get the path to the temporary directory

  local DIR_TMP

  dir_tmp_tryall

  [ "$DIR_TMP" = "" ] && { echo "Failed to find a temporary folder" >&2 ; return 1 ; }

  [ ! -d "$DIR_TMP" ] && mkdir "$DIR_TMP" && chmod 0700 "$DIR_TMP"
  symlink "$DIR_TMP" "$HOME/.tmp"
  mkdir "$DIR_TMP/cache" >/dev/null 2>&1
  symlink "$DIR_TMP/cache" "$HOME/.cache"
  echo "$DIR_TMP"

}

dir_tmp_tryall() {

  dir_tmp_one "$ROOT/dev/shm" && return 0
  dir_tmp_one "$ROOT/run/shm" && return 0
  dir_tmp_one "$ROOT/tmp" && return 0
  dir_tmp_one "$ROOT/var/tmp" && return 0

}

dir_tmp_one () {

  [ -w "$1" ] || return 1

  mount | grep '\(tmpfs\|ramfs\)' | grep $1 >/dev/null || return 1
  DIR_TMP="$1/$USER"

}

path_bin () { # Finds the path to the binary

  [ "$#" -ne "1" ] && return 2

  path_hasbin "$1" && type "$1" | awk '{print $3}' && return 0

  return 1

}

proc_exists () { # Checks to see if the process is running

  [ "$#" -ne "1" ] && return 1

  kill -0 $1 >/dev/null 2>&1

}

check_pidfile () { # Checks the pidfile to see if the process is running

  [ -f "$1" ] && proc_exists "$(cat $1 2>/dev/null)"

}

path_add () { # Add to the path if the DIR doesn't exist

  if [ "$(echo "$PATH" | grep "$1" 2>/dev/null)" = "" ] ; then
    export PATH="${PATH}:$1"
  fi

}

sudo_wrap () { # Wraps the command in sudo if sudo exists and runs it

  if path_hasbin "sudo" ; then
    sudo $@
  else
    $@
  fi

}

tolower () {

  echo "$@" | tr '[A-Z]' '[a-z]'

}

toupper () {

  echo "$@" | tr '[a-z]' '[A-Z]'

}

dir_check () {

  [ -d "$1" ] || { echo "Creating directory: $1" ; mkdir -p "$1" ; return $? ; }

  return 0

}

dir_exist () {

  dir_check "$1" || { echo "ERROR: failed to create directory: $1" ; }

  return 0

}

file_check () {

  [ -f "$1" ] || { echo "Creating file: $1" ; touch "$1" ; return $? ; }

  return 0

}

file_exist () {

  file_check "$1" || { echo "ERROR: failed to create file: $1" ; }

  return 0

}
