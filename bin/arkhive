#!/use/bin/env bash
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: ARKhive h.264
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Dependencies:
##      fdkaac
##      ffmpeg[encode,ffprobe,fdkaac,threads]
##      mkvtoolnix[mkvextract,mkvmerge]
##      opus
##      VobSub2SRT
##      x264
##      Obviously: awk, bash, cat, grep, pwd, tail, rm
##    Assumed Directory & File Structure:
##      /usr/bin?
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      <> - issue description
##      # -- commented variables

VERSION=3

## [audio]
#audioBitrate
#audioSampleRate
#audioLanguage

## [video]
#videoBitrate
#videoFrameRate
#videoResolution

## [subtitles]
#subtitleLanguage

## [Exit Codes]
# 0 = Success
# 1 = Input Error
# 2 = Could Not Find Value Error

## [colors]
clR="\033[1;31m"  # Red
clG="\033[1;32m"  # Green
clW="\033[1;37m"  # White
clP="\033[1;35m"  # Purple
clGa="\033[0;30m" # Gray
clC="\033[0;36m"  # Cyan (light blue)
clY="\033[0;33m"  # Yellow
clU="\033[0;4m"   # Underline
clD="\033[0;0m"   # default

usage () {
    HELP="\n\${clC}ARKhive version:\${clG} ${VERSION}
\${clC}Automated video encoding according to Chlorm's ARK specifications.

Usage: \${clD}arkhive [\${clU}\${clP}OPTIONS\$clD] \${clU}\${clP}FILE\$clD [\${clU}\${clP}OPTIONS\$clD]\$clD
    \$clG-i|--input  \${clU}\${clP}FILE\$clD          \$clY*\$clD - set input file\$clD
    \$clG-o|--output \${clU}\${clP}DIRECTORY\$clD       - set output directory\$clD
    \$clG-t|--temp   \${clU}\${clP}DIRECTORY\$clD       - set temp directory\$clD
    \$clG-h|--help\$clD                   - print this message
    \$clG-v|--version\$clD                - print version\n\n"
}

usage

if [ -z "$1" ]; then
    echo -e "${clR}ERROR: No arguments provided"
    exit 1
else
  ## [parse arguments]
  # Parse Arguments
  while [ "$1" ]; do
    case "$1" in
      -i|--input)
        if [ -z "$2" ]; then
          echo -e "${clR}ERROR: No input provided"
          exit 1
        elif [ -f "$2" ]; then
          inputFileExt=${2##*.}
          case "$inputFileExt" in
            avi|f4v|flv|m2ts|m4v|mkv|mp4|mpeg|mpg|mov|ts|wmv)
              userInput="$2"
              shift
            ;;
            *)
              printf "${clR}ERROR: Selected file is not a supported format!\n";
              printf "${clY}Supported: avi,f4v,flv,m2ts,m4v,mkv,mp4,mpeg,mpg,mov,ts,wmv\n";
              exit 1
            ;;
          esac
        else
          printf "${clR}ERROR: Input file does not exist\n"
          exit 1
        fi
      ;;
      -o|--output)
        if [ -z "$2" ]; then
          echo -e "${clR}ERROR: No output directory provided"
          exit 1
        elif [ ! -d "$2" ]; then
          echo -e "${clR}ERROR: Output is not a directory"
          exit 1
        else
          userOutput=$2
          shift
        fi
      ;;
      -t|--temp)
        if [ -z "$2" ]; then
          echo -e "${clR}ERROR: No temp directory provided"
          exit 1
        elif [ ! -d "$2" ]; then
          echo -e "${clR}ERROR: Temp is not a directory"
          exit 1
        else
          userTemp="$2"
          shift
        fi
      ;;
      -ve|--videoencoder)
        videoEncoder="$2"
        shift
      ;;
      -h|--help) eval "printf \"${HELP}\"";exit 1;;
      -v|--version)
        printf "ARKhive version: ${VERSION}\n\n";exit 1;;
      -*) eval "printf \"${HELP}\"";printf "\n${clR}ERROR: Unknown option $1\n";exit 1;;
      *)
        if [ -n "${INPATH}" ]; then
          eval "printf \"${HELP}\""
          printf "\n${clR}ERROR: Unknown option $1\n";exit 1
        elif [ ! -r "$1" ]; then
          printf "${clR}ERROR: Unable to read $1\n";exit 1
        else
          INPATH="$1"
        fi
      ;;
    esac
    shift
  done
fi

# Make sure user has provided input
if [ -z "$userInput" ]; then
  eval "printf \"${HELP}\""
  echo -e "${clR}ERROR: no input provided"
  exit 
fi

input_directory () {
  # Input file directory
  cd $(dirname $userInput)
  pwd
}

output_directory () {
  # Output directory
  if [ -z "$userOutput" ]; then
    input_directory
  else
    cd $userOutput
    pwd
  fi
}

temp_directory () {
  # Temp directory
  if [ -z "$userTemp" ]; then
    input_directory
  else
    cd $userTemp
    pwd
  fi
}

filename () {
  # Input filename w/ ext
  fileName=$(basename "$userInput")

  # Input filename w/o ext
  fileName=$(echo "$fileName" | sed -r 's/\.[[:alnum:]]+$//')

  # Add tag
  arkMark="-ARK"
  echo "$fileName$arkMark"
}

cpu_cores () {
  ## [cpu cores]
  local cpuCores=$(awk '/^cpu\ cores/{print $4;exit}' /proc/cpuinfo)
  if [ -z "$cpuCores" ]; then
    echo -e "${clR}ERROR: Could not find # of cpu cores"
    exit 2; fi
  echo "$cpuCores"
}

cpu_threads () {
  ## [cpu threads]
  local cpuThreads=$(grep -c ^processor /proc/cpuinfo)
  if [ -z "$cpuCores" ]; then
    echo -e "${clR}ERROR: Could not find # of cpu threads"
    exit 2; fi
  echo "$cupThreads"
}

## TODO: case for subtitle without language set
## TODO: use for loop to find all english subs in file
##		after finding subs look for plain text subs
## TODO: parse vobsub2srt output and remove ERROR:... lines
## TODO: add support for PGS subtitles
##      if pgs use bdsup2sub to covert to sub/idx and then vobsub2srt
subtitles () {
  ## [find if video has subtitles]
  hasSubtitles=$(\
    ffprobe $userInput 2>&1 | \
    awk '/Subtitle/ { print $2 }')

  ## [no subtitles were found]
  if [ -z "$hasSubtitles" ]; then
    return 0
  ## [subtitles were found]
  else
    ## [finds first english subtitle stream]
    subtitleStream=$(\
      ffmpeg -i $userInput -f null - 2>&1 | \
      grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Subtitle)' | \
      awk -F ":" '{print $2}' | tail -1)

    if [ -z "subtitleStream" ]; then echo "no english subtitles found"; fi

    mkvextract -q tracks $userInput $subtitleStream:temp_directory/filename 2>/dev/null
    echo -e "       ${clC}Found English Subs, Stream: ${clP}$subtitleStream"

    ## [check for and convert VobSub to SRT]
    if [ -f "$tempFilePath/$fileName.idx" ]; then
      echo "         Converting VobSub to SRT"
      vobsub2srt $(temp_directory)/$(filename) &>/dev/null || \
      { echo "WARNING: failed to convert vobsub to srt"; }; fi
  fi
}

chapters () {
  ## [find chapters if any]
  hasChapters=$(ffprobe $userInput 2>&1 | awk '/Chapter/ { print $2 }')

  ## [no chapters were found]
  if [ -z "$hasChapters" ]; then
    echo "Video has no chapters"
  ## [chapters were found]
  else
    mkvextract \
      chapters \
      --simple $userInput \
      --redirect-output $(temp_directory)/$(filename).xml
  fi
}

## TODO: Test for und (undetermined language) and for alternatelanguages if eng not found
## TODO: account for alternate container formats (m2ts)
## Contaier Formats: avi flv/f4v m2ts mpeg mkv mov mp4/m4v ts wm
## TODO: Move audioChannels out of if statements for code reuse
audio_input_stream () {
  # Add all streams with audio to an array
  audioStreamArray=($(ffprobe -i test4.mp4 2>&1 | \
    grep "Audio:" | \
    awk '/Stream\ #0:/ { print $2 }' | \
    grep -o -P '(?<=\#0\:).*(?=\([a-zA-Z]+)'))

  # Find total number of audio streams
  $audioStreamCount=$($audioStreamArray[@])

  if [ "$audioStreamCount" = "1" ]; then
    #set to stream number and call it a day
  elif [ "$audioStreamCount" -gt "1" ]; then
    # get pounded in the ass

    # Not sure where to start with this section

  # Find language of audio stream
  ffprobe -i test4.mp4 2>&1 | \
    # Gets line of streams
    grep "Stream #0:1" | \
    # Pulls first part of line containing language
    awk '/Stream\ #0:1/ { print $2 }' | \
    # Pulls the three digit language code
    grep -m 1 -o -P '(?<=\#0\:1\().*(?=\):)'

  # 3 
  #  if only one audio stream take it
  #  if not, see if any audio streams contain english
  #    if so, see if there are multiples
  #      select best option 
  #  if not, see if there is anything other than "und"
  #  if not, see if there are multiple und
  #    if so, pick best option
  else
    echo "ERROR: Video has no audio"
    exit 2
  fi

  # 4 Fuck Bitches
}

audio_input_sample_rate () {
  ## [offset audio stream by one for ffprobe because it counts from zero]
  #audioChnStream=$(( $audioEngStream - 1 ))

  ffprobe -i $userInput 2>&1 | \
    # TODO: input audio stream to grep
    grep -m 1 "Stream #0:$primaryAudioStream" | \
    awk -F ", " '/Hz/ { print $2 }'
}

audio_input_channels () {
  findChannels=$(ffprobe -i $userInput 2>&1 | \
    # TODO: input audio stream to grep
    grep -m 1 "Stream #0:$primaryAudioStream" | \
    # TODO: input audio_input_sample_rate functio to awk
    awk -F ", " '/44100\ Hz/ { print $3 }')
  if [ $findChannels = "mono" ]; then
    echo
  elif [ $findChannels = "mono" ]; then
    echo
  elif [ $findChannels = "5.1(side)" ]; then
    echo
  elif [ $findChannels = "mono" ]; then
    echo
  elif [ $findChannels = "mono" ]; then
    echo
  elif [ $findChannels = "mono" ]; then
    echo
  elif [ $findChannels = "mono" ]; then
    echo
  elif [ $findChannels = "mono" ]; then
    echo
  else
    echo "ERROR: somethin broke nigga"
  fi
}

audio () {
  ## [set to 48kbps per channel]
  audioBitrate=$(($audioChannels * 48))
  audioBitrateUnit="k"
  audioBitrate="$audioBitrate$audioBitrateUnit"
}

crop_detect () {
  ## [several checks to accurately crop black-bars]
  crop="1"
  totalLoops="10"
  ## [gather crop values]
  A=0
  while [ "$A" -lt "$totalLoops" ]; do
    A="$(( $A + 1 ))"
    skipSecs="$(( 120 * $A ))"
    crop[$A]=$(\
      ffmpeg -threads $(cpu_cores) -i $userInput -ss $skipSecs \
      -t 1 -vf cropdetect -f null - 2>&1 | \
      awk -F "=" '/crop/ { print $NF }' | tail -1)
    echo -ne "\r       ${clC}crop detect ${clP}$A ${clC}of ${clP}10 ${clC}complete"
  done
  B=0
  while [ "$B" -lt "$totalLoops" ]; do
    B="$(( $B + 1 ))"
    C=0
    while [ "$C" -lt "$totalLoops" ]; do
      C="$(( $C + 1 ))"
      if [ "${crop[$B]}" == "${crop[$C]}" ]; then
        countCrop[$B]="$(( ${countCrop[$B]} + 1 ))"
      fi
    done
  done
  ## [find greatest crop]
  highestCount=0
  D=0
  while [ "$D" -lt "$totalLoops" ]; do
    D="$(( $D + 1 ))"
    if [ "${countCrop[$D]}" -gt "$highestCount" ]; then
      highestCount="${countCrop[$D]}"
      greatest="$D"
    fi
  done
  ## [final crop value]
  crop="${crop[$greatest]}"
  ## [frame width from final crop value]
  cropWidth=$(echo $crop | awk -F ":" '{print $1}')
  echo -e "\n             Crop: ${clP}$crop"
}

# Call Functions
chapters
subtitles
audio

# Encode Audio
ffmpeg \
-i "$userInput" \
-c:a libfdk_aac \
-map 0:$audioEngStream \
-ac $audioChannels \
-b:a $audioBitrate \
-ar 48000 \
-y $(temp_directory)/$(filename).aac || \
{ echo -e "${clR}ERROR: audio failed to encode";exit 0; }

# Frames Per Second
FPS="23.976023976"
# Get Duration
totalLength=$(ffprobe "$userInput" 2>&1 | sed -n "s/.* Duration: \([^,]*\), .*/\1/p")
HRS=$(echo $totalLength | cut -d":" -f1)
MIN=$(echo $totalLength | cut -d":" -f2)
SEC=$(echo $totalLength | cut -d":" -f3)
# Get total number of frames
totalFrames=$(echo "($HRS*3600+$MIN*60+$SEC)*$FPS" | bc | cut -d"." -f1)
echo "Estimated total frames: $totalFrames"

# Number of encoding passes
passes="2"

# Initial pass number, DO NOT CHANGE VALUE
PASS="1"

while [ $PASS -le $passes ]; do

  echo -e "${clC}Encoding Pass: ${clP}$PASS ${clC}of ${clP}$passes${clD}"

  # x264
  if [ $videoEncoder == "x264" ]; then
    ffmpeg \
      -threads $cpuThreads \
      -i "$userInput" \
      -vf "crop=$crop,scale=$cropWidth:trunc(ow/a/2)*2" \
      -r 24000/1001 \
      -pix_fmt yuv420p \
      -f yuv4mpegpipe - |
    x264
      --demuxer y4m
      --cabac --ref=4
      --deblock=1:-1:-1
      --analyse=0x3:0x133
      --me=umh
      --subme=9
      --psy
      --psy-rd=0:0
      --mixed-ref
      --merange=24
      --trellis=2
      --8x8dct
      --cqm=jvt
      --deadzone-inter=21
      --deadzone-intra=11
      --no-fast-pskip
      --chroma-qp-offset=-3
      --threads=8
      --lookahead-threads=1
      --nr=0
      --no-interlaced
      --constrained-intra
      --bframes=3
      --b-pyramid=2
      --b-adapt=2
      --b-bias=0
      --direct=temporal
      --weightb
      --weightp=2
      --keyint=250
      --min-keyint=2
      --scenecut=40
      --rc-lookahead=60
      --pass=1
      --mbtree
      --cplxblur=20.0
      --qblur=0.5
      --ratetol=1.
      --qcomp=0.60
      --qpmin=0
      --qpmax=69
      --qpstep=
      --fps=24000/1001
      --bitrate=1762
      --nal-hrd=vbr
      --vbv-maxrate=31250
      --vbv-bufsize=31250
      --ipratio=1.40
      --aq=1.0
      --output $(temp_directory)/$(filename).avc -

  # x265 (default)
  else
    ## [ffmpeg piped to x265]
    ## TODO: determine if crop height or width are odd numbers and if so
    ##        enable ffmpeg scaling otherwise disable
    ## TODO: make ffmpeg output to $fileName.ffmpeg
    ffmpeg \
      -threads $(cpu_threads) \
      -i "$userInput" \
      -vf "crop=$crop,scale=$cropWidth:trunc(ow/a/2)*2" \
      -r 24000/1001 \
      -pix_fmt yuv420p \
      -f yuv4mpegpipe - 2> nul | \
    x265 \
      --y4m \
      --stats=$tempFilePath/$fileName.stats \
      --threads=$(cpu_cores) \
      --frame-threads=$cpuCores \
      --wpp \
      --ctu=64 \
      --no-cutree \
      --tu-intra-depth=4 \
      --tu-inter-depth=4 \
      --me=2 \
      --cbqpoffs=3 \
      --crqpoffs=3 \
      --psy-rd=0.15 \
      --subme=7 \
      --merange=60 \
      --ref=4 \
      --bframes=3 \
      --b-pyramid \
      --b-adapt=2 \
      --bframe-bias=0 \
      --b-intra \
      --weightb \
      --weightp \
      --bitrate=1024 \
      --vbv-init=0.9 \
      --vbv-bufsize=31250 \
      --vbv-maxrate=31250 \
      --no-slow-firstpass \
      --pass=$PASS \
      --keyint=250 \
      --min-keyint=23 \
      --rc-lookahead=60 \
      --no-constrained-intra \
      --aq-mode=0 \
      --lft \
      --sao-lcu-opt=1 \
      --cbqpoffs=-3 \
      --crqpoffs=-3 \
      --rect \
      --amp \
      --max-merge=5 \
      --no-early-skip \
      --no-tskip \
      --hash=2 \
      -f 0 \
      -o "$(temp_directory)/$(filename).hvc" - || \
      { echo "ERROR: video encoding failed";exit 0; }
  fi

  # Finished encoding
  if [ $PASS == $passes ]; then
    echo
    echo "Encoding complete"
  # Not finised encoding
  else 
    echo; fi

  # Increment pass count
  PASS="$(( $PASS + 1 ))"
done

# mkvmerge
# -o "$rar_variable-s.mkv"
# "--default-track" "0:yes"
# "--forced-track" "0:no"
# "--language" "1:eng"
# "--track-name"
# "1:English"
# "--default-track"
# "1:yes"
# "--forced-track"
# "1:no"
# "--language" "2:eng"
# "--default-track" "2:yes" "--forced-track"
# "2:no" "-a" "1" "-d" "0" "-s" "2" "-T" "--no-global-tags"
# "--no-chapters" "(" "$rlsname_variable.mkv" ")"
# "--track-order" "0:0,0:1,0:2" "--split" "parts:00:01:30-00:02:30"

    ## [check for chaper file]
    if [ -f "$(temp_directory)/$(filename).xml" ]; then
        muxChapters="--chapters $(temp_directory)/$(filename).xml"
    else
        muxChapters=""; fi

    ## [check for subtitle file]
    if [ -f "$(temp_directory)/$(filename).srt" ]; then
        muxSubtitles="$(temp_directory)/$(filename).srt"
    else
        muxSubtitles=""; fi

    ## TODO: find audio language and set videolanguage to audiolanguage
    mkvmerge \
        -o $(output_directory)/$(filename).mkv \
        --title $(filename) \
        -A $(temp_directory)/$(filename).hvc \
        $muxChapters \
        $muxSubtitles \
        $(temp_directory)/$(filename).aac

## ffmpeg redirected output [nul]

## [delete video]
if [ -f "$(temp_directory)/$(filename).hvc" ]; then
  rm $(temp_directory)/$(filename).hvc
  echo "Removed $(filename).hvc"; fi

## [delete x265 multi-pass log]
if [ -f "$(temp_directory)/$(filename).stats" ]; then
  rm $(temp_directory)/$(filename).stats
  echo "Removed $(filename).stats"; fi

## [delete audio]
if [ -f "$(temp_directory)/$(filename).opus" ]; then
  rm $(temp_directory)/$(filename).aac
  echo "Removed $(filename).aac"; fi

## [delete subtitles]
if [ -f "$(temp_directory)/$(filename).sub" ]; then
  rm $(temp_directory)/$(filename).sub
  echo "Removed $(filename).sub"; fi
if [ -f "$(temp_directory)/$(filename).idx" ]; then
  rm $(temp_directory)/$(filename).idx
  echo "Removed $(filename).idx"; fi
if [ -f "$(temp_directory)/$(filename).srt" ]; then
  rm $(temp_directory)/$(filename).srt
  echo "Removed $(filename).srt"; fi

## [delete chapter list]
if [ -f "$(temp_directory)/$(filename).xml" ]; then
  rm $(temp_directory)/$(filename).xml
  echo "Removed $(filename).xml"; fi